<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NZ Medicinal Cannabis Product Terpene Comparison</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  body {
    font-family: 'Poppins', sans-serif;
    margin: 0;
    padding: 20px;
  }
  h1 {
    font-size: 16px;
    margin: 0 0 4px 0;
  }
  h2 {
    font-size: 10px;
    margin: 0 0 12px 0;
    font-weight: 400;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    font-size: 0.8rem;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 4px;
    text-align: center;
    white-space: nowrap;
    word-wrap: break-word;
  }
  th {
    cursor: pointer;
    background-color: #f4f4f4;
    position: sticky;
    top: 0;
    z-index: 3;
    border-bottom: 2px solid #999;
    line-height: 1.2em;
    max-width: 80px;
  }
  td:first-child, th:first-child {
    position: sticky;
    left: 0;
    background-color: #f4f4f4;
    text-align: left;
    z-index: 5; /* raised for mobile */
    cursor: pointer; /* indicate clickability */
  }
  td:last-child, th:last-child {
    text-align: left;
  }
  td.shaded {
    color: #000;
    width: 80px; 
  }
  /* row highlight */
  tr.highlight {
    background-color: rgba(255, 215, 0, 0.25) !important;
  }
  /* extra highlight just for first column of highlighted row */
  tr.highlight td:first-child {
    background-color: rgba(255, 215, 0, 0.55) !important;
    font-weight: 600;
  }
  /* italicised cells (not first column) */
  td.italicised {
    font-style: italic;
  }
</style>
</head>
<body>

<h1>NZ Medicinal Cannabis Product Terpene Comparison - approx % w/w</h1>
<h2>List of products taken from the <a href="https://www.health.govt.nz/regulation-legislation/medicinal-cannabis/information-for-health-professionals/minimum-quality-standard-medicinal-cannabis-products" style=text-decoration: underline;" target="_blank">Ministry of Health list of medicinal cannabis products that meet the minimum quality standard</a>.<br>Product data taken from crowd sourced supplier published product data information sheets.<br>Click column headers to sort. Where total terpenes data was unavailable terpene values have been normalised to 1% w/w (italicised).</h2>

<table id="spreadsheet">
  <thead>
    <tr id="headerRow"></tr>
  </thead>
  <tbody id="tableBody"></tbody>
</table>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script>
// CSV URL
const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTww6fpAXf2v9iAoHDaMmlT44fgIggpFPAKubK9xRsDQfpdnquC3JYt2sL54Mn6Bgl-ld3jjQR7QIXP/pub?gid=869048094&single=true&output=csv";

let tableData = [];
let sortDirections = [];
let highlightedRow = null; // track currently highlighted row

// Load CSV
fetch(csvUrl)
  .then(res => res.text())
  .then(text => {
    tableData = Papa.parse(text, {header: false}).data;
    buildTable();
  });

// Build table
function buildTable() {
  const headerRow = document.getElementById('headerRow');
  const tableBody = document.getElementById('tableBody');
  headerRow.innerHTML = '';
  tableBody.innerHTML = '';

  // Filter rows with empty first column
  let bodyData = tableData.slice(1).filter(r => r[0] && r[0].trim() !== '');

  // Initialize sort directions
  sortDirections = new Array(tableData[0].length).fill(null);

  // Header
  tableData[0].forEach((col, index) => {
    const th = document.createElement('th');
    th.textContent = col;
    th.addEventListener('click', () => sortColumn(index));
    headerRow.appendChild(th);
  });

  renderTableBody(bodyData);
}

// Render table body
function renderTableBody(data) {
  const tbody = document.getElementById('tableBody');
  tbody.innerHTML = '';

  const shadedCols = Array.from({length: data[0].length}, (_, i) => i)
                          .filter(i => i > 0 && i < data[0].length - 1);

  // Compute min/max for shading
  const minMax = {};
  shadedCols.forEach(col => {
    const numbers = data.map(r => parseFloat(r[col])).filter(n => !isNaN(n));
    minMax[col] = {min: Math.min(...numbers), max: Math.max(...numbers)};
  });

  data.forEach(row => {
    const tr = document.createElement('tr');

    // check if last column contains "normalised"
    const lastCell = row[row.length - 1] || "";
    const isNormalised = lastCell.toLowerCase().includes("normalised");

    row.forEach((cell, idx) => {
      const td = document.createElement('td');
      td.textContent = cell;

      if (idx === 0) {
        // Make product name clickable to toggle highlight
        td.addEventListener('click', () => {
          if (highlightedRow === tr) {
            // toggle off
            tr.classList.remove('highlight');
            highlightedRow = null;
          } else {
            document.querySelectorAll('#tableBody tr').forEach(r => r.classList.remove('highlight'));
            tr.classList.add('highlight');
            highlightedRow = tr;
          }
        });
      } else {
        // italicise only non-first-column cells if row is "normalised"
        if (isNormalised) {
          td.classList.add("italicised");
        }
      }

      if (shadedCols.includes(idx)) {
        const val = parseFloat(cell);
        if (!isNaN(val)) {
          const {min, max} = minMax[idx];
          const percent = max === min ? 1 : (val - min) / (max - min);
          if (idx === 1) {
            td.style.backgroundColor = `rgba(0, 150, 0, ${percent * 0.5 + 0.1})`;
          } else {
            td.style.backgroundColor = `rgba(0, 150, 255, ${percent * 0.5 + 0.1})`;
          }
          td.classList.add('shaded');
        } else if (cell.trim() !== '') {
          // Text value: shade purple
          td.style.backgroundColor = 'rgba(150, 0, 150, 0.1)';
          td.classList.add('shaded');
        }
      }

      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

// Sort column
function sortColumn(colIndex) {
  let direction = sortDirections[colIndex] === 'desc' ? 'asc' : 'desc';
  sortDirections[colIndex] = direction;

  let bodyData = tableData.slice(1).filter(r => r[0] && r[0].trim() !== '');

  bodyData.sort((a, b) => {
    const aVal = parseFloat(a[colIndex]);
    const bVal = parseFloat(b[colIndex]);

    if (!isNaN(aVal) && !isNaN(bVal)) return direction === 'desc' ? bVal - aVal : aVal - bVal;
    if (!isNaN(aVal)) return -1;
    if (!isNaN(bVal)) return 1;

    if (a[colIndex] && b[colIndex]) return direction === 'desc' ? b[colIndex].localeCompare(a[colIndex]) : a[colIndex].localeCompare(b[colIndex]);
    if (a[colIndex]) return -1;
    if (b[colIndex]) return 1;

    return 0;
  });

  renderTableBody(bodyData);
}
</script>

</body>
</html>
