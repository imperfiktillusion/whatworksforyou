<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spreadsheet Viewer</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  body {
    font-family: 'Poppins', sans-serif;
    margin: 0;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    font-size: 0.8rem; /* reduced font */
  }
  th, td {
    border: 1px solid #ccc;
    padding: 4px;
    text-align: center;
    white-space: nowrap;
  }
  th {
    cursor: pointer;
    background-color: #f4f4f4;
    position: sticky;
    top: 0;
    z-index: 3;
    border-bottom: 2px solid #999;
    word-wrap: break-word;
    max-width: 80px;
  }
  td:first-child, th:first-child {
    position: sticky;
    left: 0;
    background-color: #f4f4f4;
    text-align: left;
    z-index: 2;
  }
  td:last-child, th:last-child {
    text-align: left;
  }
  td.shaded {
    color: #000;
    width: 80px; /* fixed width for shaded columns */
  }
</style>
</head>
<body>

<h1>Spreadsheet Viewer</h1>
<table id="spreadsheet">
  <thead>
    <tr id="headerRow"></tr>
  </thead>
  <tbody id="tableBody"></tbody>
</table>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script>
// CSV URL
const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTww6fpAXf2v9iAoHDaMmlT44fgIggpFPAKubK9xRsDQfpdnquC3JYt2sL54Mn6Bgl-ld3jjQR7QIXP/pub?gid=869048094&single=true&output=csv";

let tableData = [];
let sortDirections = [];

// Load CSV
fetch(csvUrl)
  .then(res => res.text())
  .then(text => {
    tableData = Papa.parse(text, {header: false}).data;
    buildTable();
  });

// Build table
function buildTable() {
  const headerRow = document.getElementById('headerRow');
  const tableBody = document.getElementById('tableBody');
  headerRow.innerHTML = '';
  tableBody.innerHTML = '';

  // Filter rows with first column empty
  let bodyData = tableData.slice(1).filter(r => r[0] && r[0].trim() !== '');

  // Initialize sort directions
  sortDirections = new Array(tableData[0].length).fill(null);

  // Header
  tableData[0].forEach((col, index) => {
    const th = document.createElement('th');
    th.textContent = col;
    th.addEventListener('click', () => sortColumn(index));
    headerRow.appendChild(th);
  });

  renderTableBody(bodyData);
}

// Render table body
function renderTableBody(data) {
  const tbody = document.getElementById('tableBody');
  tbody.innerHTML = '';

  const shadedCols = Array.from({length: data[0].length}, (_, i) => i)
                          .filter(i => i > 0 && i < data[0].length - 1);

  // Compute min/max for shading
  const minMax = {};
  shadedCols.forEach(col => {
    const numbers = data.map(r => parseFloat(r[col])).filter(n => !isNaN(n));
    minMax[col] = {min: Math.min(...numbers), max: Math.max(...numbers)};
  });

  data.forEach(row => {
    const tr = document.createElement('tr');
    row.forEach((cell, idx) => {
      const td = document.createElement('td');
      td.textContent = cell;

      // Shading
      if (shadedCols.includes(idx)) {
        const val = parseFloat(cell);
        if (!isNaN(val)) {
          const {min, max} = minMax[idx];
          const percent = max === min ? 1 : (val - min) / (max - min);
          // Second column green
          if (idx === 1) {
            td.style.backgroundColor = `rgba(0, 150, 0, ${percent * 0.5 + 0.1})`;
          } else {
            td.style.backgroundColor = `rgba(0, 150, 255, ${percent * 0.5 + 0.1})`;
          }
          td.classList.add('shaded');
        }
      }

      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

// Sort column
function sortColumn(colIndex) {
  let direction = sortDirections[colIndex] === 'desc' ? 'asc' : 'desc';
  sortDirections[colIndex] = direction;

  let bodyData = tableData.slice(1).filter(r => r[0] && r[0].trim() !== '');

  bodyData.sort((a, b) => {
    const aVal = parseFloat(a[colIndex]);
    const bVal = parseFloat(b[colIndex]);

    if (!isNaN(aVal) && !isNaN(bVal)) return direction === 'desc' ? bVal - aVal : aVal - bVal;
    if (!isNaN(aVal)) return -1;
    if (!isNaN(bVal)) return 1;

    if (a[colIndex] && b[colIndex]) return direction === 'desc' ? b[colIndex].localeCompare(a[colIndex]) : a[colIndex].localeCompare(b[colIndex]);
    if (a[colIndex]) return -1;
    if (b[colIndex]) return 1;

    return 0;
  });

  renderTableBody(bodyData);
}
</script>

</body>
</html>
