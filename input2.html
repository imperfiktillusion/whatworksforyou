<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <base href="https://imperfiktillusion.github.io/whatworksforyou/input">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>What works for you?</title>

  <!-- Fonts / Charts / CSV parser -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <style>
    /* === Visual improvements (same "plus" changes as other page) === */
    :root{
      --muted:#666;
      --card-bg:#fff;
      --accent:#f8f8f8;
      --gap:12px;
      --max-col-width:270px;
    }
    html,body{height:100%;margin:0;font-family:Poppins,Arial,Helvetica,sans-serif;background:#f5f5f5;color:#222}
    .container{max-width:1200px;margin:0 auto;padding:18px}
    .page-title{font-size:28px;margin:48px 0 10px 0;font-weight:300}
    .section-title{font-size:20px;margin:14px 0;font-weight:300;color:var(--muted)}
    #loading{padding:10px;font-style:italic;color:var(--muted)}

    /* accordions */
    .accordion, .condition-accordion, .myproducts-accordion{width:100%;margin-bottom:18px}
    .accordion-item, .condition-accordion-item, .myproducts-accordion-item{background:var(--card-bg);border-radius:8px;border:1px solid #e5e5e5;overflow:hidden;margin-bottom:8px}
    .accordion-header, .condition-accordion-header, .myproducts-accordion-header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;background:var(--accent);cursor:pointer}
    .accordion-header span:first-child, .condition-accordion-header span:first-child, .myproducts-accordion-header span:first-child{font-size:18px;font-weight:600}
    .accordion-content, .condition-accordion-content, .myproducts-accordion-content{padding:0 16px 16px 16px;max-height:0;overflow:hidden;transition:max-height .28s ease}
    .accordion-content.active, .condition-accordion-content.active, .myproducts-accordion-content.active{max-height:1200px}

    /* grid improvements */
    .conditions-grid, .products-grid{display:grid;gap:10px;grid-template-columns:repeat(auto-fit,minmax(var(--max-col-width),1fr));align-items:start}
    .grid-column{display:flex;flex-direction:column;gap:6px}
    .condition-checkbox, .product-checkbox{display:flex;align-items:center;gap:8px;padding:6px 4px}
    .condition-checkbox label, .product-checkbox label{font-size:14px;white-space:nowrap;cursor:pointer}

    /* reports container */
    .accordion-content-container{background:var(--card-bg);padding:12px;border-radius:6px;border:1px solid #eee;margin-top:10px}
    #ConditionsReport, #SideEffectsReport, .UndesiredEffectsReport{display:grid;gap:8px}
    /* small helpers */
    .effects-notice{font-size:13px;color:var(--muted);font-style:italic;margin:6px 0}
    .small-muted{font-size:12px;color:var(--muted)}
    /* mobile tweaks */
    @media (max-width:640px){
      .page-title{font-size:20px;margin-top:28px}
      :root{--max-col-width:180px}
      .accordion-header, .condition-accordion-header, .myproducts-accordion-header{padding:10px}
    }
  </style>
</head>

<body>
  <div class="container">
    <h1 class="page-title">Crowd sourcing answers. Which medical cannabis options work best for your condition?</h1>

    <!-- Condition selector accordion -->
    <div class="condition-accordion">
      <div class="condition-accordion-item">
        <div class="condition-accordion-header"><span>I am prescribed medical cannabis for…</span></div>
        <div class="condition-accordion-content">
          <div class="conditions-grid" id="conditions-grid"><!-- filled from CSV --></div>
        </div>
      </div>
    </div>

    <div class="section-title">My medical cannabis products</div>

    <!-- Product accordion (individual product pages / reports) -->
    <div class="accordion" id="product-accordion"><!-- filled from CSV --></div>

    <!-- MyProducts accordion -->
    <div class="myproducts-accordion">
      <div class="myproducts-accordion-item">
        <div class="myproducts-accordion-header"><span>Add a product +</span></div>
        <div class="myproducts-accordion-content">
          <div class="products-grid" id="products-grid"><!-- filled from CSV --></div>
        </div>
      </div>
    </div>

    <div id="loading">Loading data...</div>

    <!-- Hidden debug / data area preserved for parity -->
    <div id="data-section" style="display:none">
      <div id="spreadsheet1"></div>
      <div id="spreadsheet2"></div>
      <div id="spreadsheet3"></div>
    </div>
  </div>

  <script>
  /**************************************************************************
   * CSV-based loader + UI builder
   * Mirrors the approach used on the other page:
   * - PapaParse CSV
   * - Build conditions grid, products grid, accordion
   * - Per-product unique report containers (no duplicated IDs)
   * - Preserve original logic & warnings
   **************************************************************************/

  // --- Your CSV URLs (same ones you gave previously) ---
  const PRODUCTS_CSV = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTww6fpAXf2v9iAoHDaMmlT44fgIggpFPAKubK9xRsDQfpdnquC3JYt2sL54Mn6Bgl-ld3jjQR7QIXP/pub?gid=0&single=true&output=csv';
  const CONDITIONS_CSV = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQDPYraFDktD7EtJ7T06_FGu4fszOWQ0cA0Yr0DsP3B6N9WYRofdReaZKurPsWEMW1-kelb9RTGGgps/pub?gid=0&single=true&output=csv';
  const EFFECTIVENESS_CSV = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQDPYraFDktD7EtJ7T06_FGu4fszOWQ0cA0Yr0DsP3B6N9WYRofdReaZKurPsWEMW1-kelb9RTGGgps/pub?gid=1303283638&single=true&output=csv';

  // Tables stored as 2D arrays (rows of columns)
  let productsTable = [];
  let conditionsTable = [];
  let effectTable = [];

  const effectivenessOptions = ["Not effective","Mild benefit","Good benefit","This is exactly what I need"];
  // Utility: normalize string
  const norm = s => ('' + (s||'')).trim().toLowerCase();

  // Fetch CSV and parse into 2D array
  async function fetchCSV(url) {
    const cache = '&_ts=' + Date.now();
    const res = await fetch(url + cache, {cache:'no-store'});
    if (!res.ok) throw new Error('CSV fetch failed: ' + res.status);
    const text = await res.text();
    const parsed = Papa.parse(text.trim(), {skipEmptyLines:true}).data;
    return parsed;
  }

  // Choose start index similar to previous heuristics (header row, product-names row, data from 2)
  function dataStartIndex(table) {
    if (!table || table.length === 0) return 0;
    return table.length > 2 ? 2 : 1;
  }

  // Make a safe slug from product name for unique IDs
  function slug(s) { return ('' + (s||'')).replace(/\s+/g,'-').replace(/[^A-Za-z0-9\-_]/g,'').toLowerCase(); }

  // Escape HTML
  function esc(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // DOM helpers
  function el(tag, attrs={}, html=''){ const e=document.createElement(tag); for(const k in attrs){ if(k==='cls') e.className=attrs[k]; else if(k==='text') e.textContent=attrs[k]; else e.setAttribute(k,attrs[k]); } if(html) e.innerHTML=html; return e; }

  // build conditions grid
  function buildConditionsGrid(){
    const grid = document.getElementById('conditions-grid');
    grid.innerHTML = '';
    const start = dataStartIndex(conditionsTable);
    const conditions = [];
    for(let i=start;i<conditionsTable.length;i++){
      const r = conditionsTable[i];
      if(!r || !r[0]) continue;
      const c = r[0].trim();
      if(!c || norm(c) === 'conditions') continue;
      conditions.push(c);
    }

    // Distribute into columns (4 columns like previous, but responsive)
    const cols = 4;
    const perCol = Math.ceil(conditions.length/cols) || 1;
    for(let col=0; col<cols; col++){
      const column = el('div',{cls:'grid-column'});
      const startIdx = col*perCol;
      const slice = conditions.slice(startIdx, startIdx+perCol);
      slice.forEach((condition,i)=>{
        const id = `cond-${slug(condition)}-${startIdx+i}`;
        const wrap = el('label',{cls:'condition-checkbox', for:id});
        wrap.innerHTML = `<input type="checkbox" id="${id}" value="${esc(condition)}"> <span>${esc(condition)}</span>`;
        column.appendChild(wrap);
        // event with confirm logic handled centrally
        const checkbox = column.querySelector(`#${id}`);
        addCheckboxEventListener(checkbox, updateProductDisplay);
      });
      grid.appendChild(column);
    }
  }

  // build products grid (My Products)
  function buildProductsGrid(){
    const grid = document.getElementById('products-grid');
    grid.innerHTML = '';
    const start = dataStartIndex(productsTable);
    const products=[];
    for(let i=start;i<productsTable.length;i++){
      const r=productsTable[i]; if(!r||!r[0]) continue;
      const p=r[0].trim(); if(p) products.push(p);
    }
    // distribute evenly into 4 columns
    const cols=4;
    const perCol = Math.ceil(products.length/cols)||1;
    for(let col=0; col<cols; col++){
      const column = el('div',{cls:'grid-column'});
      const startIdx = col*perCol;
      const slice = products.slice(startIdx, startIdx+perCol);
      slice.forEach((product,i)=>{
        const id = `prod-${slug(product)}-${startIdx+i}`;
        const wrap = el('label',{cls:'product-checkbox', for:id});
        wrap.innerHTML = `<input type="checkbox" id="${id}" value="${esc(product)}"> <span>${esc(product)}</span>`;
        column.appendChild(wrap);
        const checkbox = column.querySelector(`#${id}`);
        addCheckboxEventListener(checkbox, updateProductAccordionVisibility);
      });
      grid.appendChild(column);
    }
  }

  // build product accordion
  function buildProductAccordion(){
    const container = document.getElementById('product-accordion');
    container.innerHTML = '';
    const start = dataStartIndex(productsTable);
    for(let i=start;i<productsTable.length;i++){
      const row = productsTable[i]; if(!row||!row[0]) continue;
      const productName = row[0].trim();
      const strain = row[5] ? row[5].trim() : '';
      const thc = row[6] ? row[6].trim() : '';
      const cbd = row[7] ? row[7].trim() : '';
      const dominance = row[8] ? row[8].trim() : '';
      const bg = getDominanceColor(dominance);
      const prodSlug = slug(productName);

      // unique IDs for reports inside each accordion panel
      const conditionsReportId = `ConditionsReport-${prodSlug}`;
      const sideEffectsReportId = `SideEffectsReport-${prodSlug}`;
      const undesiredReportId = `UndesiredEffectsReport-${prodSlug}`;
      const effectsNoticeId = `EffectsNotice-${prodSlug}`;

      const reportsHTML = `
        <div class="accordion-content-container">
          <div id="${conditionsReportId}" class="ConditionsReport"></div>
          <div id="${sideEffectsReportId}" class="SideEffectsReport"></div>
          <div id="${undesiredReportId}" class="UndesiredEffectsReport"></div>
          <div id="${effectsNoticeId}" class="effects-notice" style="display:none">Please only report effects that impact your decision to use this product</div>
        </div>`;

      const item = el('div',{cls:'accordion-item'});
      item.innerHTML = `
        <div class="accordion-header" style="background:${bg}">
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
            <span>${esc(productName)}</span>
            ${strain?`<span style="font-weight:400;font-size:13px">[${esc(strain)}]</span>`:''}
            ${dominance?`<span style="font-weight:400;font-size:13px">${esc(dominance)}</span>`:''}
            ${thc?`<span style="font-weight:400;font-size:13px">${esc(thc)}% THC</span>`:''}
            ${cbd?`<span style="font-weight:400;font-size:13px">${esc(cbd)}% CBD</span>`:''}
          </div>
          <div class="small-muted product-reports" data-product="${esc(productName)}">0 reports</div>
        </div>
        <div class="accordion-content">${reportsHTML}</div>
      `;
      container.appendChild(item);

      // wire header click
      const header = item.querySelector('.accordion-header');
      header.addEventListener('click', function(){
        const content = this.nextElementSibling;
        // close others
        document.querySelectorAll('.accordion-content').forEach(c=>{ if(c!==content) c.classList.remove('active'); });
        content.classList.toggle('active');
        if(content.classList.contains('active')){
          // populate reports for this product
          updateConditionsReport(productName, prodSlug);
        }
      });
    }
  }

  // --- helpers to find product column in effectTable (same logic/heuristics) ---
  function findProductColumnInEffectTable(productName){
    if(!effectTable || effectTable.length===0) return -1;
    const tryRows = effectTable.length>1 ? [1,0,2] : [0];
    for(const rIdx of tryRows){
      if(rIdx>=effectTable.length) continue;
      const row = effectTable[rIdx]||[];
      for(let c=0;c<row.length;c++){
        if(norm(row[c])===norm(productName)) return c;
      }
    }
    // fallback scan small window
    for(let r=0;r<Math.min(effectTable.length,4);r++){
      const row = effectTable[r]||[];
      for(let c=0;c<row.length;c++){
        if(norm(row[c])===norm(productName)) return c;
      }
    }
    return -1;
  }

  // get product score & reports (mirror previous behavior)
  function getProductScore(productName, condition){
    const col = findProductColumnInEffectTable(productName);
    if(col===-1) return {score:0,reports:0};
    const start = dataStartIndex(effectTable);
    let score=0,reports=0;
    for(let i=start;i<effectTable.length;i++){
      const row = effectTable[i]||[];
      const v = parseFloat(row[col]);
      if(!isNaN(v)) reports += v;
      const rowCondition = (row[0]||'').trim().toLowerCase();
      const rowType = (row[1]||'').trim().toLowerCase();
      if(condition && rowCondition===condition.trim().toLowerCase() && rowType==='score'){
        score = parseFloat(row[col])||0;
      }
    }
    return {score,reports};
  }

  // undesired effects list for product
  function getUndesiredEffects(productName){
    const col = findProductColumnInEffectTable(productName);
    if(col===-1) return [];
    const start = dataStartIndex(effectTable);
    const effects=[];
    let hasAcceptable=false;
    for(let i=start;i<effectTable.length;i++){
      const row=effectTable[i]||[];
      const rowType=(row[0]||'').trim().toLowerCase();
      if(rowType==='undesired effects'){
        const name=row[1]||'Unnamed';
        const val=parseFloat(row[col])||0;
        if(name.toLowerCase()==='only acceptable side effects') hasAcceptable=true;
        if(val>0) effects.push({name,val});
      }
    }
    if(!hasAcceptable) effects.unshift({name:'Only acceptable side effects', value:0});
    return effects;
  }

  // effect breakdown for a product/condition
  function getEffectivenessData(productName, condition){
    if(!condition) return {effectiveness:[], totalReports:0};
    const col = findProductColumnInEffectTable(productName);
    if(col===-1) return {effectiveness:[], totalReports:0};
    const start = dataStartIndex(effectTable);
    const effectTypes = ['Not effective','Mild benefit','Good benefit','This is exactly what I need'];
    const results=[];
    for(let i=start;i<effectTable.length;i++){
      const row=effectTable[i]||[];
      const rowCondition=(row[0]||'').trim();
      const effectType=(row[1]||'').trim();
      if(rowCondition.toLowerCase()===condition.toLowerCase() && effectTypes.includes(effectType)){
        const v=parseFloat(row[col])||0;
        if(v>0) results.push({name:effectType,value:v});
      }
    }
    const total = results.reduce((s,it)=>s+it.value,0);
    return {effectiveness:results, totalReports:total};
  }

  // create charts / lists (reused style)
  function createDataList(data, limit=null, isEffectiveness=false){
    if(isEffectiveness){
      const canvas = el('canvas'); canvas.style.height='260px';
      const effectTypes=['Exactly what I need','Good benefit','Mild benefit','Not effective'];
      const chartData = effectTypes.map(type => {
        const found = data.find(it => (type==='Exactly what I need' ? it.name==='This is exactly what I need' : it.name===type));
        return found ? found.value : 0;
      });
      const total = chartData.reduce((a,b)=>a+b,0);
      const percentages = chartData.map(v => total? (v/total)*100:0);
      new Chart(canvas,{type:'bar',data:{labels:effectTypes,datasets:[{data:percentages, backgroundColor:['#8cd82d','#c6eb96','#e3f5cc','#b8b8b8']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false},tooltip:{enabled:false}},scales:{y:{display:false}}}});
      return canvas;
    } else {
      const canvas = el('canvas'); canvas.style.height='260px';
      let sorted = data.map(d=>({name:d.name,value:d.value}));
      const acceptableIndex = sorted.findIndex(s=>s.name==='Only acceptable side effects');
      const acceptableItem = acceptableIndex>-1 ? sorted.splice(acceptableIndex,1)[0] : null;
      sorted = sorted.sort((a,b)=>b.value-a.value).slice(0,9);
      if(acceptableItem) sorted.unshift(acceptableItem);
      const total = sorted.reduce((s,it)=>s+it.value,0);
      const percentages = sorted.map(it => total? (it.value/total)*100 : 0);
      new Chart(canvas,{type:'pie',data:{labels:sorted.map(s=>s.name),datasets:[{data:percentages}]},options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{position:'right'}}}});
      return canvas;
    }
  }

  // update per-product reports when accordion opened
  function updateConditionsReport(productName, prodSlug){
    const conditionsReportId = `ConditionsReport-${prodSlug}`;
    const sideEffectsReportId = `SideEffectsReport-${prodSlug}`;
    const undesiredReportId = `UndesiredEffectsReport-${prodSlug}`;
    const effectsNoticeId = `EffectsNotice-${prodSlug}`;

    const condEl = document.getElementById(conditionsReportId);
    const sideEl = document.getElementById(sideEffectsReportId);
    const undesEl = document.getElementById(undesiredReportId);
    const notice = document.getElementById(effectsNoticeId);

    if(!condEl || !sideEl || !undesEl) return;

    // Clear
    condEl.innerHTML=''; sideEl.innerHTML=''; undesEl.innerHTML='';

    // Selected conditions
    const selectedConditions = Array.from(document.querySelectorAll('.condition-checkbox input:checked')).map(cb=>cb.value);
    // If none selected, show prompt
    if(selectedConditions.length===0){
      condEl.innerHTML = `<div class="small-muted">Select your conditions in the top accordion to rate this product.</div>`;
    } else {
      // Build title
      const title = el('div',{cls:'conditions-title'},`Please rate how effective ${esc(productName)} is for each of your conditions`);
      condEl.appendChild(title);

      // For each condition -> display radio groups
      const cols = ['', '', '', '']; // we will append columns for each effectiveness option
      // First column shows the condition label
      const labelCol = el('div',{cls:'grid-column'});
      selectedConditions.forEach(c => {
        labelCol.appendChild(el('div',{cls:'condition-checkbox'},`<strong>${esc(c)}</strong>`));
      });
      condEl.appendChild(labelCol);

      // For each effectiveness option create a column
      effectivenessOptions.forEach(opt=>{
        const colDiv = el('div',{cls:'grid-column'});
        selectedConditions.forEach(c=>{
          const rbName = `eff-${slug(productName)}-${slug(c)}`;
          const id = `${rbName}-${slug(opt)}`;
          const wrapper = el('label',{cls:'condition-checkbox', for:id});
          wrapper.innerHTML = `<input type="radio" name="${rbName}" id="${id}" value="${esc(opt)}"> <span>${esc(opt)}</span>`;
          colDiv.appendChild(wrapper);
          // radios: when chosen, show/hide undesired effects this panel only
          const radio = wrapper.querySelector('input[type=radio]');
          radio.addEventListener('change', function(){
            const show = this.value==='Some uncomfortable side effects' || this.value==='Side effects prohibit use';
            // NOTE: we use the per-panel undesEl & notice
            undesEl.style.display = show ? 'grid' : 'none';
            notice.style.display = show ? 'block' : 'none';
          });
        });
        condEl.appendChild(colDiv);
      });
    }

    // Side effects summary (radio group)
    const sideLabelCol = el('div',{cls:'grid-column'});
    sideLabelCol.innerHTML = `<div><strong>Side effects</strong></div>`;
    sideEl.appendChild(sideLabelCol);

    const sideOptions = ["Only acceptable side effects","Some uncomfortable side effects","Side effects prohibit use"];
    sideOptions.forEach(opt=>{
      const col = el('div',{cls:'grid-column'});
      const id = `side-${prodSlug}-${slug(opt)}`;
      col.innerHTML = `<label class="condition-checkbox" for="${id}"><input type="radio" name="side-${prodSlug}" id="${id}" value="${esc(opt)}"> <span>${esc(opt)}</span></label>`;
      sideEl.appendChild(col);

      const radio = col.querySelector('input[type=radio]');
      radio.addEventListener('change', function(){
        const show = this.value==='Some uncomfortable side effects' || this.value==='Side effects prohibit use';
        undesEl.style.display = show ? 'grid' : 'none';
        notice.style.display = show ? 'block' : 'none';
        // If switching to 'Only acceptable...' and previous had uncomfortable selected, warn
        if(this.value==='Only acceptable side effects'){
          // check previous selection - naive: if any other side radio for this product had been checked before (we can't easily get previous value here), ask confirm anyway
          if(!confirm('Are you sure you want to delete your side effects report?')) {
            // revert
            this.checked=false;
          }
        }
      });
    });

    // Populate undesired effects (from effectTable 'undesired effects' rows) into this panel
    const undesireds = [];
    // find undesired effects from effectTable like previous function
    const start = dataStartIndex(effectTable);
    for(let i=start;i<effectTable.length;i++){
      const row = effectTable[i]||[]; const rowType=(row[0]||'').trim().toLowerCase();
      if(rowType==='undesired effects'){
        const name = (row[1]||'').trim();
        if(name && !undesireds.includes(name)) undesireds.push(name);
      }
    }
    // split undesireds into 4 columns
    undesEl.style.display='none'; // hidden until side effects radio selects show
    undesEl.innerHTML='';
    const chunk = Math.ceil(Math.max(undesireds.length,1)/4);
    for(let c=0;c<4;c++){
      const col = el('div',{cls:'grid-column'});
      const slice = undesireds.slice(c*chunk, c*chunk+chunk);
      slice.forEach((name, idx)=>{
        const id = `undes-${prodSlug}-${c}-${idx}`;
        const wrapper = el('label',{cls:'condition-checkbox', for:id});
        wrapper.innerHTML = `<input type="checkbox" id="${id}" value="${esc(name)}"> <span>${esc(name)}</span>`;
        col.appendChild(wrapper);
      });
      undesEl.appendChild(col);
    }

    // update reports count label in header
    const headerReports = document.querySelector(`.product-reports[data-product="${productName}"]`);
    if(headerReports){
      const tot = calculateTotalReportsForProduct(productName);
      headerReports.textContent = `${Math.round(tot)} reports`;
    }
  }

  // calculate total reports for product by summing its column in effectTable
  function calculateTotalReportsForProduct(productName){
    const col = findProductColumnInEffectTable(productName);
    if(col===-1) return 0;
    const start = dataStartIndex(effectTable);
    let sum = 0;
    for(let i=start;i<effectTable.length;i++){
      const row = effectTable[i]||[];
      const v = parseFloat(row[col]);
      if(!isNaN(v)) sum += v;
    }
    return sum;
  }

  // update product summary display when conditions selected
  function updateProductDisplay(){
    const selected = Array.from(document.querySelectorAll('.condition-checkbox input:checked')).map(cb=>cb.value);
    document.querySelectorAll('.selected-condition').forEach(s=> s.textContent = selected.join(', '));
  }

  // show/hide products in accordion based on MyProducts selection
  function updateProductAccordionVisibility(){
    const selected = Array.from(document.querySelectorAll('.product-checkbox input:checked')).map(cb=>cb.value);
    const items = document.querySelectorAll('#product-accordion .accordion-item');
    items.forEach(item=>{
      const name = item.querySelector('.accordion-header span:first-child').textContent.trim();
      item.style.display = selected.length===0 ? 'block' : (selected.includes(name) ? 'block' : 'none');
    });
  }

  // Add checkbox event listener with confirm on unselect (keeps your original behavior)
  function addCheckboxEventListener(checkbox, updateFn){
    if(!checkbox) return;
    checkbox.addEventListener('change', function(){
      if(!this.checked){
        if(!confirm('Warning: Unselecting will delete your report. Are you sure?')){
          this.checked = true;
          return;
        }
      }
      // call update function and persist
      if(typeof updateFn === 'function') updateFn();
      saveSelectionsToLocalStorage();
    });
  }

  // localStorage helpers
  function saveSelectionsToLocalStorage(){
    const conds = Array.from(document.querySelectorAll('.condition-checkbox input:checked')).map(cb=>cb.value);
    const prods = Array.from(document.querySelectorAll('.product-checkbox input:checked')).map(cb=>cb.value);
    localStorage.setItem('wwfy_selectedConditions', JSON.stringify(conds));
    localStorage.setItem('wwfy_selectedProducts', JSON.stringify(prods));
  }
  function loadSelectionsFromLocalStorage(){
    try{
      const conds = JSON.parse(localStorage.getItem('wwfy_selectedConditions')||'[]');
      const prods = JSON.parse(localStorage.getItem('wwfy_selectedProducts')||'[]');
      // apply to checkboxes (if they exist)
      document.querySelectorAll('.condition-checkbox input').forEach(cb=>{ if(conds.includes(cb.value)) cb.checked=true; });
      document.querySelectorAll('.product-checkbox input').forEach(cb=>{ if(prods.includes(cb.value)) cb.checked=true; });
    }catch(e){ console.error('localStorage load error',e) }
  }

  // dominance color (preserve mapping)
  function getDominanceColor(d){
    const n = (d||'').toLowerCase().trim();
    if(n==='sativa dominant') return '#ffea8a';
    if(n==='indica dominant') return '#9be7f5';
    if(n==='balanced hybrid') return '#bee8a6';
    if(n==='unknown') return '#d1e6cb';
    return '#EAEAEA';
  }

  // update product-report counts (used after CSV loaded)
  function refreshAllReportCounts(){
    document.querySelectorAll('.product-reports').forEach(el=>{
      const productName = el.getAttribute('data-product');
      const tot = calculateTotalReportsForProduct(productName);
      el.textContent = `${Math.round(tot)} reports`;
    });
  }

  // main loader
  async function loadAll(){
    const loading = document.getElementById('loading');
    try{
      loading.textContent = 'Loading CSVs…';
      const [p,c,e] = await Promise.all([fetchCSV(PRODUCTS_CSV), fetchCSV(CONDITIONS_CSV), fetchCSV(EFFECTIVENESS_CSV)]);
      productsTable = p || []; conditionsTable = c || []; effectTable = e || [];
      // optional: display raw html in debug area for parity (kept but hidden)
      document.getElementById('spreadsheet1').innerHTML = '<!-- products loaded -->';
      document.getElementById('spreadsheet2').innerHTML = '<!-- lists loaded -->';
      document.getElementById('spreadsheet3').innerHTML = '<!-- effectiveness loaded -->';
      // build UI
      buildConditionsGrid();
      buildProductsGrid();
      buildProductAccordion();
      // restore selections
      loadSelectionsFromLocalStorage();
      // apply any selection effects
      updateProductDisplay();
      updateProductAccordionVisibility();
      refreshAllReportCounts();
      loading.style.display='none';
      console.log('CSV load complete.');
    }catch(err){
      console.error('Load error', err);
      loading.textContent = 'Error loading CSVs — check console.';
    }
  }

  // wire up top accordions open/close
  document.addEventListener('DOMContentLoaded', ()=>{
    document.querySelectorAll('.condition-accordion-header').forEach(h=>{
      h.addEventListener('click', ()=>{ const c=h.nextElementSibling; c.classList.toggle('active'); });
    });
    document.querySelectorAll('.myproducts-accordion-header').forEach(h=>{
      h.addEventListener('click', ()=>{ const c=h.nextElementSibling; c.classList.toggle('active'); });
    });
    // kick off load
    loadAll();
  });

  </script>
</body>
</html>
